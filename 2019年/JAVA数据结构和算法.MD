# JAVA 数据结构和算法

## 一. 简单排序

### 1. 冒泡排序
> * 基本思路：对未排序的各元素从头到尾依次比较相邻的两个元素是否逆序（与欲排顺序相反），若逆序就交换两个元素，经过第一轮比较排序后便可能最大（或最小）的元素排好，然后再用同样的方法把剩余的元素逐个进行排序，就得到所要的排序结果了。

>* 效率：比较和交换次数都为0（N的平方）

### 2. 选择排序
> * 基本思路：从所有元素中选择一个最小元素a[i]放在a[0]（即让最小元素a[i]与a[0]交换）,作为第一轮；第二轮是从a[1]开始到最后的各个元素中选择一个最小元素，放在a[1]中；... 依次类推。 n个数要进行（n-1）轮

### 3. 插入排序

>* 基本思路：每拿到一个元素，都要将这个元素与所有它之前的元素遍历比较一遍，让符合排序顺序的元素挨个移动到当前范围内它最应该出现的位置

>* 效率：比较和交换次数都为0(N的平方),大致为N(N-1)/4,所以这个算法比冒泡大致快了一倍，比比较排序略快，尤其是部分数据已经局部有序的情况下，这个算法效率会更高

### 4. 对象排序
>* 其实还是比较对象里面的某个或某些属性值来进行排序

## 二. 数据结构

### 1.线性表

* 什么是线性表
> 线性表也被称为顺序表，是一个线性序列结构，它是一个含有n>=0个节点的有限序列，对于其中的节点，有且仅有一个开始节点没有前驱但有一个后续节点，有且仅有一个终端节点没有后续但有一个前驱节点，其他的节点都有且仅有一个前驱和一个后续节点

* 线性表和数组的关系
> 1.是两种不同的数据结构，数组有维度的概念，线性表没有；而线性表有前驱节点和后续节点的概念，线性表的数据是相互有关联的，而数组没有这些。
> 2.线性表可以使用数组，通常是一维数组来作为其数据的存储结构

### 2.栈
> 栈是一种特殊的线性表，限定只能在表的一端进行插入和删除操作，俗称"后进先出"（FILO）。 操作数据的这端就是表头，称为栈顶；相应地，表尾称为栈底。不含任何元素的栈称为空栈。

#### 2.1 栈的基本操作

* PUSH 压栈/入栈操作
* POP 弹栈/出栈操作
* PEEK 产看栈顶数据，而不弹出数据，也就是不做出栈操作
#### 2.3 栈的应用实例
1. 字符串倒序
2. 括号（小、中、大）匹配
3. 算术表达式转后缀表达式
4. 运算后缀表达式

#### 2.4 后缀表达式
* 什么是后缀表达式
>后缀表达式，也成为波兰逆序表达式，由波兰数学家卢卡西维奇发明的一种表达式的方法。这种表示方式把运算法写在运算对象的后面，例如，把a+b 写成ab+,所以也成为后缀表达式。
这种表达式的优点是更具运算对象和运算符的出现次序进行计算，不需要使用括号，也便于用程序来实现求值。
* 如何把中缀表达式转换成后缀表达式
>说明：把中缀表达式转换成后缀表达式不用做算术运算，只是把操作符和操作数重新按照后缀表达式的方式进行排列而已。

#### 2.5 栈的效率
> 栈的出栈和入栈的时间复杂度都为常数，也就是O(1),不涉及复制和移动操作

### 3.队列

#### 3.1 什么是队列
> 队列是一种特殊的线性表，限定只能在表的一端进行插入（队尾），而在另一端进行删除操作（队头），特点"先进先出”FIFO

#### 3.2 队列的基本操作
* insert 在队尾插入数据
* remove 在队头移出数据
* peek 查看队头的数据

#### 3.3 循环队列
> 为了避免队列不满，却不能插入新数据项的问题，可以让队头队尾的指针绕回到数组开始的位置，这就是循环队列，也称为缓冲环。

#### 3.4 队列的效率
>插入和移出数据项的时间复杂度均为O(1)

#### 3.5 双端队列
>所谓双端队列，就是一个两端都可以进行数据插入和移出操作的队列。它综合提供了栈和队列的功能，并不是很常用，了解即可。

#### 3.6 优先级队列
>优先级队列就是数据项按照关键字排好顺序的队列。

#### 3.7 优先级队列的效率
>这里练习的优先级队列是升降序的队列，插入需要O(N),而删除需要O(1)，后面学习堆的时候，可以来改进优先级队列的插入速度。

### 4.链表
>链表也是一种特殊的线性表，它由一系列结点组成，结点的顺序是通过结点元素中的指针链接次序来确定的。 链表中的结点包含两个部分，一个是它自身需存放的数据，另一个是指向下一个节点的引用。


### 4.1 链表和数组
* 都可作为数据的存储结构
* 数组：固定长度，顺序存放
* 链表：没有容量限制，非连续和非顺序的存储结构
* 从效率上说，链表基本上完胜数组
* 基本上，能用数组的地方，都可以用链表来代替，链表的缺点是引入了复杂度。

### 4.2 链表操作
* 向链表中插入数据
* 移走数据
* 查看所有数据
* 查找指定位置的数据
* 删除指定位置的数据

### 4.3 单链表的效率

>在表头插入和删除非常快，基本就是修改一下引用值，时间大约为常量，即为O(1)。 查找、删除等功能，大约需要O(N)次比较，跟数组差不多，但仍然比数组快，因为它不需要移动和复制数据。

### 4.4 双端链表
>所谓双端链表是不仅仅记录着开始结点，同事也记录着结束结点。 注意：双端和双向不是一个意思。

### 4.5 有序链表
>所有的有序链表就是顺序被排好序的链表。

### 4.5.1 有序链表的效率
>插入和删除，大约需要O(N)次比较

### 4.6 使用有序链表来实现插入排序
>思路：把数据依次插入到有序链表，然后再依次读取出来，这就已经排好序了。
效率：比数组插入法更高，因为这种方式下，数据的复制次数要少一些，每个节点只需要2*N次复制，而数组中需要N的平方次复制。


### 4.6 双向链表
> 双端链表记录了首尾节点数据，而双向链表在此基础上，每个节点都维护了上一个节点和下一个节点数据，是双端链表的升级。

## 5.常见算法

### 5.1 递归

>什么是递归？递归就是函数（方法）不断调用自身，直至求出结果的算法，其思路是把一个大问题转化为规模缩小的子问题，通过解决小问题来解决最终的大问题。

#### 5.1.1 阶乘问题

#### 5.1.2 二分法查找

#### 5.1.3 分治算法
>基本思想是将一个大的问题分解为N个较小的子问题，这些子问题相互独立且原问题性质相同。求出子问题的解，就可得到原问题的解。

#### 5.1.4 斐波那切数列
>0，1，1，2，3，5，8，13，21...

#### 5.1.5 汉诺塔（河内塔）问题

#### 5.1.6 背包问题
>背包问题是一种组合优化的问题，一种简化形式如下： 给定一组物品，重量各不相同，如何从中选择物品放入背包中，以使背包重量达到指定的重量。

#### 5.1.7 归并排序
>思路：采用分治思想，把数据序列分成两个子序列，排序每一半，然后再把排好序的两个子序列合并成为一个有序的序列。

#### 5.1.8 希尔排序

#### 5.1.9 快速排序


#### 5.1.10 基数排序

## 6.树

### 7. 二叉树

#### 6.1红黑树

###

